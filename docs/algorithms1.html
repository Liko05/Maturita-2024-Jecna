<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-05-13T22:10:19.345492"><title>2. Algoritmizace - Grafy, Prohl&eacute;d&aacute;v&aacute;n&iacute; stavov&eacute;ho prostoru, Řazen&iacute; | Maturita</title><script type="application/json" id="virtual-toc-data">[{"id":"vlastnosti-algoritm","level":0,"title":"Vlastnosti algoritmů","anchor":"#vlastnosti-algoritm"},{"id":"grafy","level":0,"title":"Grafy","anchor":"#grafy"},{"id":"prohl-d-v-n-stavov-ho-prostoru","level":0,"title":"Prohlédávání stavového prostoru","anchor":"#prohl-d-v-n-stavov-ho-prostoru"},{"id":"azen","level":0,"title":"Řazení","anchor":"#azen"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="2. Algoritmizace - Grafy, Prohl&eacute;d&aacute;v&aacute;n&iacute; stavov&eacute;ho prostoru, Řazen&iacute; | Maturita"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Maturita Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//20.24/algorithms1.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="2. Algoritmizace - Grafy, Prohl&eacute;d&aacute;v&aacute;n&iacute; stavov&eacute;ho prostoru, Řazen&iacute; | Maturita"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//20.24/algorithms1.html#webpage",
    "url": "writerside-documentation//20.24/algorithms1.html",
    "name": "2. Algoritmizace - Grafy, Prohl&eacute;d&aacute;v&aacute;n&iacute; stavov&eacute;ho prostoru, Řazen&iacute; | Maturita",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Maturita Help"
}</script><!-- End Schema.org --></head><body data-id="Algorithms1" data-main-title="2. Algoritmizace - Grafy, Prohlédávání stavového prostoru, Řazení" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Questions-PV.md|PV"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Maturita 20.24 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Algorithms1" id="Algorithms1.md">2. Algoritmizace - Grafy, Prohlédávání stavového prostoru, Řazení</h1><ul class="list _bullet" id="gsvkck_2"><li class="list__item" id="gsvkck_3"><p>Algoritmy jsou postupy ře&scaron;en&iacute; probl&eacute;mů pro jednotliv&eacute; probl&eacute;my.</p></li><li class="list__item" id="gsvkck_4"><p>Každ&yacute; algoritmus m&aacute; svou složitost, kter&aacute; se d&aacute; vyj&aacute;dřit časovou a paměťovou složitost&iacute;.</p></li><li class="list__item" id="gsvkck_5"><p>Z&aacute;sadně je tvořen jednoznačn&yacute;m postupem, zaručuje že pro spr&aacute;vn&yacute; vstup vr&aacute;t&iacute; spr&aacute;vn&yacute; v&yacute;stup.</p></li></ul><section class="chapter"><h2 id="vlastnosti-algoritm" data-toc="vlastnosti-algoritm">Vlastnosti algoritmů</h2><ul class="list _bullet" id="gsvkck_6"><li class="list__item" id="gsvkck_7"><p><span class="control" id="gsvkck_8">Hromadnost</span> - Měniteln&aacute; vstupn&iacute; data.</p></li><li class="list__item" id="gsvkck_9"><p><span class="control" id="gsvkck_10">Determinovanost</span> - Každ&yacute; krok je jednoznačně definov&aacute;n.</p></li><li class="list__item" id="gsvkck_11"><p><span class="control" id="gsvkck_12">Konečnost a resultativnost</span> - Pro spr&aacute;vn&yacute; vstup vr&aacute;t&iacute; spr&aacute;vn&yacute; v&yacute;stup.</p></li></ul></section><section class="chapter"><h2 id="grafy" data-toc="grafy">Grafy</h2><ul class="list _bullet" id="gsvkck_13"><li class="list__item" id="gsvkck_14"><p><span class="control" id="gsvkck_15">[G]raf</span> je množina vrcholů a hran, kter&eacute; spojuj&iacute; vrcholy. Slouž&iacute; k reprezentaci vztahů mezi objekty. Znač&iacute;me G(V,E) </p><ul class="list _bullet" id="gsvkck_16"><li class="list__item" id="gsvkck_17"><p><span class="control" id="gsvkck_18">[V]rchol</span> - Objekt, kter&yacute; je reprezentov&aacute;n v grafu.</p></li><li class="list__item" id="gsvkck_19"><p><span class="control" id="gsvkck_20">Hrana/[E]dge</span> - Relace mezi dvěma vrcholy.</p></li><li class="list__item" id="gsvkck_21"><p><span class="control" id="gsvkck_22">Využit&iacute;</span> - Např&iacute;klad pro hled&aacute;n&iacute; nejkrat&scaron;&iacute; cesty, detekci cyklů, nebo pro reprezentaci dat.</p></li></ul></li></ul><section class="chapter"><h3 id="zn-zorn-n-grafu" data-toc="zn-zorn-n-grafu">Zn&aacute;zorněn&iacute; grafu:</h3><section class="chapter"><h4 id="ilustrace" data-toc="ilustrace">Ilustrace</h4><figure id="gsvkck_23"><img alt="Graf" src="https://media.geeksforgeeks.org/wp-content/uploads/undirectedgraph.png" title="Graf"></figure></section><section class="chapter"><h4 id="matrix" data-toc="matrix">Matrix</h4><figure id="gsvkck_24"><img alt="Matice" src="https://media.geeksforgeeks.org/wp-content/uploads/adjacencymatrix.png" title="Matice"></figure></section></section><section class="chapter"><h3 id="z-kladn-operace-pro-grafy" data-toc="z-kladn-operace-pro-grafy">Z&aacute;kladn&iacute; operace pro grafy:</h3><ul class="list _bullet" id="gsvkck_25"><li class="list__item" id="gsvkck_26"><div class="table-wrapper"><table class="wide" id="gsvkck_27"><thead><tr class="ijRowHead" id="gsvkck_28"><th id="gsvkck_29"><p>Operace</p></th><th id="gsvkck_30"><p>Popis</p></th></tr></thead><tbody><tr id="gsvkck_31"><td id="gsvkck_32"><p><span class="control" id="gsvkck_33">Vložen&iacute; vrcholu</span></p></td><td id="gsvkck_34"><p>Vložen&iacute; nov&eacute;ho vrcholu do grafu.</p></td></tr><tr id="gsvkck_35"><td id="gsvkck_36"><p><span class="control" id="gsvkck_37">Vložen&iacute; hrany</span></p></td><td id="gsvkck_38"><p>Vložen&iacute; nov&eacute; hrany mezi vrcholy.</p></td></tr><tr id="gsvkck_39"><td id="gsvkck_40"><p><span class="control" id="gsvkck_41">Smaz&aacute;n&iacute; vrcholu</span></p></td><td id="gsvkck_42"><p>Smaz&aacute;n&iacute; vrcholu z grafu.</p></td></tr><tr id="gsvkck_43"><td id="gsvkck_44"><p><span class="control" id="gsvkck_45">Smaz&aacute;n&iacute; hrany</span></p></td><td id="gsvkck_46"><p>Smaz&aacute;n&iacute; hrany mezi vrcholy.</p></td></tr><tr id="gsvkck_47"><td id="gsvkck_48"><p><span class="control" id="gsvkck_49">V&yacute;pis grafu</span></p></td><td id="gsvkck_50"><p>V&yacute;pis grafu.</p></td></tr><tr id="gsvkck_51"><td id="gsvkck_52"><p><span class="control" id="gsvkck_53">Prohled&aacute;v&aacute;n&iacute; grafu</span></p></td><td id="gsvkck_54"><p>Prohled&aacute;v&aacute;n&iacute; grafu.</p></td></tr></tbody></table></div></li></ul></section><section class="chapter"><h3 id="code-example_1" data-toc="code-example_1">Code example</h3><div class="code-block" data-lang="java">
class Graph&lt;T&gt; {
    private Map&lt;T, List&lt;T&gt;&gt; map = new HashMap&lt;&gt;();
    
    public void addVertex(T s) {
        map.put(s, new LinkedList&lt;T&gt;());
    }
    
    public void addEdge(T source, T destination, boolean bidirectional) {
        if (!map.containsKey(source)) addVertex(source);
        if (!map.containsKey(destination)) addVertex(destination);
        map.get(source).add(destination);
        if (bidirectional) map.get(destination).add(source);
    }
    
    public void getVertexCount() {
        System.out.println(&quot;The graph has &quot; + map.keySet().size() + &quot; vertex&quot;);
    }
    
    public void hasVertex(T s)
    {
        if (map.containsKey(s)) {
            System.out.println(&quot;The graph contains &quot; + s
                               + &quot; as a vertex.&quot;);
        }
        else {
            System.out.println(&quot;The graph does not contain &quot;
                               + s + &quot; as a vertex.&quot;);
        }
    }
    
    public void hasEdge(T s, T d)
    {
        if (map.get(s).contains(d)) {
            System.out.println(
                &quot;The graph has an edge between &quot; + s
                + &quot; and &quot; + d + &quot;.&quot;);
        }
        else {
            System.out.println(
                &quot;The graph has no edge between &quot; + s
                + &quot; and &quot; + d + &quot;.&quot;);
        }
    }
}
</div></section></section><section class="chapter"><h2 id="prohl-d-v-n-stavov-ho-prostoru" data-toc="prohl-d-v-n-stavov-ho-prostoru">Prohl&eacute;d&aacute;v&aacute;n&iacute; stavov&eacute;ho prostoru</h2><ul class="list _bullet" id="gsvkck_56"><li class="list__item" id="gsvkck_57"><p><span class="control" id="gsvkck_58">Stavov&yacute; prostor</span> - Množina v&scaron;ech možn&yacute;ch stavů, S.</p></li><li class="list__item" id="gsvkck_59"><p><span class="control" id="gsvkck_60">Poč&aacute;tečn&iacute; stav</span> - Stav, ve kter&eacute;m se nach&aacute;z&iacute;me, s0 &isin; S</p></li><li class="list__item" id="gsvkck_61"><p><span class="control" id="gsvkck_62">C&iacute;lov&eacute; stavy</span> - Stavy, kter&eacute; chceme dos&aacute;hnout, T &sube; S</p></li><li class="list__item" id="gsvkck_63"><p><span class="control" id="gsvkck_64">Akce</span> - Operace, kterou můžeme prov&eacute;st, A</p></li><li class="list__item" id="gsvkck_65"><p><span class="control" id="gsvkck_66">Přechodov&aacute; funkce</span> - Funkce, kter&aacute; n&aacute;m ř&iacute;k&aacute;, jak se můžeme dostat z jednoho stavu do druh&eacute;ho, f : S &times; A &rarr; S</p></li></ul><section class="chapter"><h3 id="vlastnosti-prohl-d-v-n-stavov-ho-prostoru" data-toc="vlastnosti-prohl-d-v-n-stavov-ho-prostoru">Vlastnosti prohl&eacute;d&aacute;v&aacute;n&iacute; stavov&eacute;ho prostoru</h3><ul class="list _bullet" id="gsvkck_67"><li class="list__item" id="gsvkck_68"><p><span class="control" id="gsvkck_69">&Uacute;plnost</span> - Algoritmus najde c&iacute;lov&yacute; stav, pokud existuje.</p></li><li class="list__item" id="gsvkck_70"><p><span class="control" id="gsvkck_71">Optimalita</span> - Algoritmus najde nejlep&scaron;&iacute; cestu.</p></li><li class="list__item" id="gsvkck_72"><p><span class="control" id="gsvkck_73">Využit&iacute;</span> - Pl&aacute;nov&aacute;n&iacute; cesty, bludi&scaron;tě, ře&scaron;en&iacute; hlavolamů.</p></li></ul></section><section class="chapter"><h3 id="algoritmy-pro-prohl-d-v-n-stavov-ho-prostoru" data-toc="algoritmy-pro-prohl-d-v-n-stavov-ho-prostoru">Algoritmy pro prohl&eacute;d&aacute;v&aacute;n&iacute; stavov&eacute;ho prostoru</h3><ul class="list _bullet" id="gsvkck_74"><li class="list__item" id="gsvkck_75"><p><span class="control" id="gsvkck_76"><a href="https://en.wikipedia.org/wiki/Depth-first_search" id="gsvkck_77" data-external="true" rel="noopener noreferrer">DFS</a> (Depth First Search)</span></p><ul class="list _bullet" id="gsvkck_78"><li class="list__item" id="gsvkck_79"><p>Prohled&aacute;v&aacute;n&iacute; do hloubky.</p></li><li class="list__item" id="gsvkck_80"><p>Funguje n&aacute;sledovně: V každ&eacute;m stavu zkus&iacute;m něco udělat. Když už to nejde, tak se vr&aacute;t&iacute;m a zkus&iacute;m něco jin&eacute;ho.</p></li><li class="list__item" id="gsvkck_81"><p>Vlastnosti: C&iacute;l =&gt; hotovo, ozančuje si prozkouman&eacute; uzly.</p></li></ul></li></ul><section class="chapter"><h4 id="dfs" data-toc="dfs">DFS</h4><figure id="gsvkck_82"><img alt="DFS" src="https://he-s3.s3.amazonaws.com/media/uploads/9fa1119.jpg" title="DFS"></figure></section><section class="chapter"><h4 id="dfs-code-example" data-toc="dfs-code-example">DFS Code example</h4><div class="code-block" data-lang="java">
class Graph {
  private LinkedList&lt;Integer&gt; adjLists[];
  private boolean visited[];

  Graph(int vertices) {
    adjLists = new LinkedList[vertices];
    visited = new boolean[vertices];

    for (int i = 0; i &lt; vertices; i++)
      adjLists[i] = new LinkedList&lt;Integer&gt;();
  }

  void addEdge(int src, int dest) {
    adjLists[src].add(dest);
  }

  void DFS(int vertex) {
    visited[vertex] = true;
    System.out.print(vertex + &quot; &quot;);

    Iterator&lt;Integer&gt; ite = adjLists[vertex].listIterator();
    while (ite.hasNext()) {
      int adj = ite.next();
      if (!visited[adj])
        DFS(adj);
    }
  }
}
</div><ul class="list _bullet" id="gsvkck_84"><li class="list__item" id="gsvkck_85"><p><span class="control" id="gsvkck_86"><a href="https://en.wikipedia.org/wiki/Breadth-first_search" id="gsvkck_87" data-external="true" rel="noopener noreferrer">BFS</a> (Breadth First Search)</span></p><ul class="list _bullet" id="gsvkck_88"><li class="list__item" id="gsvkck_89"><p>Prohled&aacute;v&aacute;n&iacute; do &scaron;&iacute;řky.</p></li><li class="list__item" id="gsvkck_90"><p>Funguje n&aacute;sledovně: Hled&aacute;me v pořad&iacute; d&eacute;lky sekvence akc&iacute;. Nejprve prozkoum&aacute;me v&scaron;echny sousedy, pak jejich sousedy, atd.</p></li><li class="list__item" id="gsvkck_91"><p>Vlastnosti: Vždy najde nejkrat&scaron;&iacute; cestu, využ&iacute;v&aacute; frontu.</p></li></ul></li></ul></section><section class="chapter"><h4 id="bfs" data-toc="bfs">BFS</h4><figure id="gsvkck_92"><img alt="BFS" src="https://velog.velcdn.com/images/seongwon97/post/32e4165b-b98a-41d6-8daf-0506528cb07b/image.png" title="BFS"></figure></section><section class="chapter"><h4 id="bfs-code-example" data-toc="bfs-code-example">BFS Code example</h4><div class="code-block" data-lang="java">
class Graph {

    private int V;

    private LinkedList&lt;Integer&gt; adj[];

    Graph(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i = 0; i &lt; v; ++i)
            adj[i] = new LinkedList();
    }

    void addEdge(int v, int w) { adj[v].add(w); }

    void BFS(int s)
    {
        boolean visited[] = new boolean[V];

        LinkedList&lt;Integer&gt; queue
            = new LinkedList&lt;Integer&gt;();

        visited[s] = true;
        queue.add(s);

        while (queue.size() != 0) {

            s = queue.poll();
            System.out.print(s + &quot; &quot;);

            Iterator&lt;Integer&gt; i = adj[s].listIterator();
            while (i.hasNext()) {
                int n = i.next();
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }
}
</div></section></section></section><section class="chapter"><h2 id="azen" data-toc="azen">Řazen&iacute;</h2><ul class="list _bullet" id="gsvkck_94"><li class="list__item" id="gsvkck_95"><p><span class="control" id="gsvkck_96">Řazen&iacute;</span> - Proces, kdy se prvky v poli uspoř&aacute;daj&iacute; podle určit&eacute; vlastnosti.</p></li><li class="list__item" id="gsvkck_97"><p><span class="control" id="gsvkck_98">Algoritmy</span> - Bubble sort, Selection sort, Insertion sort, Merge sort, Quick sort, Heap sort, Radix sort.</p></li><li class="list__item" id="gsvkck_99"><p><span class="control" id="gsvkck_100">Využit&iacute;</span> - Vyhled&aacute;v&aacute;n&iacute;, statistika, datab&aacute;ze.</p></li></ul><section class="chapter"><h3 id="bubble-sort" data-toc="bubble-sort">Bubble sort</h3><ul class="list _bullet" id="gsvkck_101"><li class="list__item" id="gsvkck_102"><p><span class="control" id="gsvkck_103">Princip</span> - Porovn&aacute;v&aacute; dva sousedn&iacute; prvky a prohod&iacute; je, pokud nejsou ve spr&aacute;vn&eacute;m pořad&iacute;.</p></li><li class="list__item" id="gsvkck_104"><p><span class="control" id="gsvkck_105">Využit&iacute;</span> - Mal&eacute; pole, kde je třeba jednoduch&yacute; algoritmus.</p></li></ul><figure id="gsvkck_106"><img alt="Bubble sort" src="https://media.geeksforgeeks.org/wp-content/uploads/20230526103842/1.webp" title="Bubble sort"></figure><section class="chapter"><h4 id="bubble-sort-code-example" data-toc="bubble-sort-code-example">Bubble sort Code example</h4><div class="code-block" data-lang="java">
class BubbleSort {
    void bubbleSort(int arr[]) {
        int n = arr.length;
        for (int i = 0; i &lt; n-1; i++)
            for (int j = 0; j &lt; n-i-1; j++)
                if (arr[j] &gt; arr[j+1]) {
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
    }
}
</div></section></section><section class="chapter"><h3 id="selection-sort" data-toc="selection-sort">Selection sort</h3><ul class="list _bullet" id="gsvkck_108"><li class="list__item" id="gsvkck_109"><p><span class="control" id="gsvkck_110">Princip</span> - Najde nejmen&scaron;&iacute; prvek a prohod&iacute; ho s prvn&iacute;m prvkem. Pot&eacute; najde druh&yacute; nejmen&scaron;&iacute; prvek a prohod&iacute; ho s druh&yacute;m prvkem, atd.</p></li><li class="list__item" id="gsvkck_111"><p><span class="control" id="gsvkck_112">Využit&iacute;</span> - Mal&eacute; pole, kde je třeba jednoduch&yacute; algoritmus.</p></li></ul><figure id="gsvkck_113"><img alt="Selection sort" src="https://media.geeksforgeeks.org/wp-content/uploads/20240110164310/Selection-Sort-in-Java-660.png" title="Selection sort"></figure><section class="chapter"><h4 id="selection-sort-code-example" data-toc="selection-sort-code-example">Selection sort Code example</h4><div class="code-block" data-lang="java">
class SelectionSort {
    void sort(int arr[]) {
        int n = arr.length;
        for (int i = 0; i &lt; n-1; i++) {
            int min_idx = i;
            for (int j = i+1; j &lt; n; j++)
                if (arr[j] &lt; arr[min_idx])
                    min_idx = j;
            int temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
}
</div></section></section><section class="chapter"><h3 id="merge-sort" data-toc="merge-sort">Merge sort</h3><ul class="list _bullet" id="gsvkck_115"><li class="list__item" id="gsvkck_116"><p><span class="control" id="gsvkck_117">Princip</span> - Rozděl&iacute; pole na poloviny, dokud nezůstane jednoprvkov&eacute; pole. Pot&eacute; se pole spojuj&iacute; a řad&iacute;.</p></li><li class="list__item" id="gsvkck_118"><p><span class="control" id="gsvkck_119">Využit&iacute;</span> - Velk&eacute; pole, kde je třeba rychl&yacute; algoritmus.</p></li></ul><figure id="gsvkck_120"><img alt="Merge sort" src="https://media.geeksforgeeks.org/wp-content/uploads/20230713125040/Merge-Sort-in-Java-2-(1)-660.png" title="Merge sort"></figure></section><section class="chapter"><h3 id="quick-sort" data-toc="quick-sort">Quick sort</h3><ul class="list _bullet" id="gsvkck_121"><li class="list__item" id="gsvkck_122"><p><span class="control" id="gsvkck_123">Princip</span> - Vybere prvek jako pivot a rozděl&iacute; pole na dvě č&aacute;sti. Prav&aacute; č&aacute;st obsahuje prvky vět&scaron;&iacute; než pivot, lev&aacute; č&aacute;st obsahuje prvky men&scaron;&iacute; než pivot.</p></li><li class="list__item" id="gsvkck_124"><p><span class="control" id="gsvkck_125">Využit&iacute;</span> - Velk&eacute; pole, kde je třeba rychl&yacute; algoritmus.</p></li></ul><figure id="gsvkck_126"><img alt="Quick sort" src="https://inprogrammer.com/wp-content/uploads/2023/02/image-48.png" title="Quick sort"></figure><section class="chapter"><h4 id="quick-sort-code-example" data-toc="quick-sort-code-example">Quick sort Code example</h4><div class="code-block" data-lang="java">
class GFG {

    static void swap(int[] arr, int i, int j)
    {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    static int partition(int[] arr, int low, int high)
    {
        int pivot = arr[high];

        int i = (low - 1);

        for (int j = low; j &lt;= high - 1; j++) {

            if (arr[j] &lt; pivot) {

                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }

    static void quickSort(int[] arr, int low, int high)
    {
        if (low &lt; high) {

            int pi = partition(arr, low, high);

            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
}
</div></section></section></section><div class="last-modified">Last modified: 13 May 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="adresovani.html" class="navigation-links__prev">1. Adresov&aacute;n&iacute; a spr&aacute;va paměti - Garbage collecting, Reference/ukazatele, Struktura paměti programu</a><a href="algorithms2.html" class="navigation-links__next">3. Algoritmizace - Rekurze, Brute Force, Heuristiky, Nedeterministick&eacute; algoritmy</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>